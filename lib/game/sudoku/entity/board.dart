import 'package:copy_with_extension/copy_with_extension.dart';
import 'package:flutter/cupertino.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:sit/utils/byte_io/byte_io.dart';
import 'package:sit/utils/list2d/list2d.dart';
import 'package:sudoku_solver_generator/sudoku_solver_generator.dart';

import '../save.dart';

part "board.g.dart";

const sudokuSides = 9;

@immutable
@JsonSerializable()
@CopyWith(skipFields: true)
class SudokuCell {
  static const emptyInputNumber = 0;
  static const disableInputNumber = -1;
  final int index;

  /// A negative value (e.g., -1) indicates a pre-filled cell generated by the puzzle.
  /// The user cannot modify this value.
  /// `0` means the cell is empty and awaits user input.
  final int userInput;

  /// The correct value that the user should fill in the cell (1 to 9).
  final int correctValue;

  const SudokuCell({
    required this.index,
    this.userInput = SudokuCell.disableInputNumber,
    this.correctValue = SudokuCell.emptyInputNumber,
  }) : assert(correctValue == 0 || (1 <= correctValue && correctValue <= 9),
            "The puzzle should generate correct value in [1,9] but $correctValue");

  bool get isPuzzle => userInput < 0;

  bool get canUserInput => userInput >= 0;

  bool get emptyInput {
    assert(userInput >= 0, "Developer should check `isPuzzle` before access this");
    return userInput == 0;
  }

  bool get isSolved {
    assert(userInput >= 0, "Developer should check `isPuzzle` before access this");
    return userInput == correctValue;
  }

  @override
  bool operator ==(Object other) {
    return other is SudokuCell &&
        runtimeType == other.runtimeType &&
        userInput == other.userInput &&
        correctValue == other.correctValue;
  }

  @override
  int get hashCode => Object.hash(userInput, correctValue);

  factory SudokuCell.fromJson(Map<String, dynamic> json) => _$SudokuCellFromJson(json);

  Map<String, dynamic> toJson() => _$SudokuCellToJson(this);

  @override
  String toString() =>
      "(${SudokuBoard.getRowFrom(index)},${SudokuBoard.getColumnFrom(index)}) ${canUserInput ? "$userInput/$correctValue" : correctValue}";

  void serialize(ByteWriter writer) {
    writer.uint8(correctValue);
    writer.int8(userInput);
  }

  static SudokuCell deserialize(ByteReader reader, int index) {
    return SudokuCell(
      index: index,
      correctValue: reader.uint8(),
      userInput: reader.int8(),
    );
  }
}

@immutable
extension type const SudokuBoard(List2D<SudokuCell> _cells) {
// class SudokuBoard {
//   final List2D<SudokuCell> _cells;
//
//   const SudokuBoard(this._cells);
  factory SudokuBoard.generate({required int emptySquares}) {
    final generator = SudokuGenerator(emptySquares: emptySquares, uniqueSolution: true);
    final puzzle = generator.newSudoku;
    final solved = generator.newSudokuSolved;
    return SudokuBoard(List2D.generate(
      sudokuSides,
      sudokuSides,
      (row, column, index) => SudokuCell(
        index: index,
        userInput: puzzle[row][column] == 0 ? 0 : -1,
        correctValue: solved[row][column],
      ),
    ));
  }

  factory SudokuBoard.byDefault() {
    return SudokuBoard(
      List2D.generate(
        sudokuSides,
        sudokuSides,
        (row, column, index) => SudokuCell(
          index: index,
        ),
      ),
    );
  }

  void writeBlueprint(ByteWriter writer) {
    assert(_cells.length == sudokuSides * sudokuSides);
    writer.uint8(sudokuSides * sudokuSides);
    for (final cell in _cells) {
      cell.serialize(writer);
    }
  }

  static SudokuBoard readBlueprint(ByteReader reader) {
    final len = reader.uint8();
    final cells = <SudokuCell>[];
    for (var i = 0; i < len; i++) {
      cells.add(SudokuCell.deserialize(reader, i));
    }
    assert(cells.length == sudokuSides * sudokuSides);
    return SudokuBoard(List2D.from1D(sudokuSides, sudokuSides, cells));
  }

  bool get isSolved {
    for (final cell in _cells) {
      if (cell.isPuzzle) continue;
      if (!cell.isSolved) return false;
    }
    return true;
  }

  bool canFill({
    required int cellIndex,
    required int number,
  }) {
    final cell = _cells.getByIndex(cellIndex);
    if (!cell.canUserInput) return false;
    return true;
  }

  Iterable<SudokuCell> relatedOf(int cellIndex) sync* {
    final zone = getZone(SudokuBoardZone.getZoneIndexByIndex(cellIndex));
    for (final cell in zone._cells) {
      if (cell.index != cellIndex) yield cell; // exclude self
    }
    for (final cell in _cells.rowAt(_cells.getRowFrom(cellIndex))) {
      if (cell.index != cellIndex) yield cell; // exclude self
    }
    for (final cell in _cells.columnAt(_cells.getColumnFrom(cellIndex))) {
      if (cell.index != cellIndex) yield cell; // exclude self
    }
  }

  SudokuCell getCellByIndex(int cellIndex) {
    return _cells.getByIndex(cellIndex);
  }

  static int getRowFrom(int cellIndex) => cellIndex ~/ sudokuSides;
  static int getColumnFrom(int cellIndex) => cellIndex % sudokuSides;

  SudokuBoard changeCell(int cellIndex, int userInput) {
    final oldCells = _cells;
    final newCell = oldCells.getByIndex(cellIndex).copyWith(
          userInput: userInput,
        );
    final newCells = List2D.of(oldCells)..setByIndex(cellIndex, newCell);
    return SudokuBoard(newCells);
  }

  bool isCellOnEdge(int cellIndex) {
    return _cells.onEdge(_cells.getRowFrom(cellIndex), _cells.getColumnFrom(cellIndex));
  }

  SudokuBoardZone getZone(int zoneIndex) {
    return SudokuBoardZone(this, zoneIndex);
  }

  SudokuBoardZone getZoneWhereCell(SudokuCell cell) {
    final zoneIndex = SudokuBoardZone.getZoneIndexByIndex(cell.index);
    return getZone(zoneIndex);
  }

  int getZoneIndexWhereCell(SudokuCell cell) {
    return SudokuBoardZone.getZoneIndexByIndex(cell.index);
  }

  Edge2D? cellOnWhichEdge(SudokuCell cell) {
    return _cells.onWhichEdge(_cells.getRowFrom(cell.index), _cells.getColumnFrom(cell.index));
  }

  int? findNextCell(
    int startCellIndex,
    AxisDirection dir, {
    bool allowFilled = true,
    bool ignorePuzzle = true,
  }) {
    final row = getRowFrom(startCellIndex);
    final column = getColumnFrom(startCellIndex);
    switch (dir) {
      case AxisDirection.up:
      case AxisDirection.down:
        for (final cell in _cells.iterateColumnStartWith(
          row,
          column,
          incremental: dir == AxisDirection.down,
        )) {
          if (cell.index == startCellIndex) continue;
          if (!ignorePuzzle) return cell.index;
          if (cell.canUserInput && (cell.emptyInput || (allowFilled && !cell.isSolved))) {
            return cell.index;
          }
        }
        break;
      case AxisDirection.right:
      case AxisDirection.left:
        for (final cell in _cells.iterateRowStartWith(
          row,
          column,
          incremental: dir == AxisDirection.right,
        )) {
          if (cell.index == startCellIndex) continue;
          if (!ignorePuzzle) return cell.index;
          if (cell.canUserInput && (cell.emptyInput || (allowFilled && !cell.isSolved))) {
            return cell.index;
          }
        }
        break;
    }
    return null;
  }

  factory SudokuBoard.fromJson(dynamic json) {
    return SudokuBoard(
      List2D<SudokuCell>.fromJson(json, (value) => SudokuCell.fromJson(value as Map<String, dynamic>)),
    );
  }

  dynamic toJson() {
    return _cells;
  }

  factory SudokuBoard.fromSave(SaveSudoku save) {
    final cells = save.cells.mapIndexed(
      (row, column, index, cell) =>
          SudokuCell(index: index, userInput: cell.userInput, correctValue: cell.correctValue),
    );
    return SudokuBoard(cells);
  }

  List2D<Cell4Save> toSave() {
    return _cells.map((cell) => Cell4Save(userInput: cell.userInput, correctValue: cell.correctValue));
  }
}

@immutable
class SudokuBoardZone {
  final int zoneIndex;
  final SudokuBoard parent;
  final List2D<SudokuCell> _cells;

  SudokuBoardZone(
    this.parent,
    this.zoneIndex,
  ) : _cells = parent._cells.subview(
          rows: 3,
          columns: 3,
          rowOffset: (zoneIndex ~/ 3) * 3,
          columnOffset: (zoneIndex % 3) * 3,
        );

  int get parentRowOffset => (zoneIndex ~/ 3) * 3;

  int get parentColumnOffset => (zoneIndex % 3) * 3;
  static int getZoneIndexOf(int row, int column) {
    int x = column ~/ 3;
    int y = row ~/ 3;
    return y * 3 + x;
  }

  static int getZoneIndexByIndex(int boardIndex) {
    return getZoneIndexOf(boardIndex ~/ 9, boardIndex % 9);
  }

  ({int localRow, int localColumn}) mapBoardIndexToLocal(int boardIndex) {
    final parentRow = SudokuBoard.getRowFrom(boardIndex);
    final parentColumn = SudokuBoard.getColumnFrom(boardIndex);
    final localRow = (parentRow - parentRowOffset) % 3;
    final localColumn = (parentColumn - parentColumnOffset) % 3;
    assert(0 <= localRow && localRow < 3, "$localRow not in [0,3)");
    assert(0 <= localColumn && localColumn < 3, "$localColumn not in [0,3)");
    return (localRow: localRow, localColumn: localColumn);
  }

  Edge2D? onWhichEdge(int boardIndex) {
    final (:localRow, :localColumn) = mapBoardIndexToLocal(boardIndex);
    return _cells.onWhichEdge(localRow, localColumn);
  }

  Edge2D? cellOnWhichEdge(SudokuCell cell) {
    return onWhichEdge(cell.index);
  }
}
